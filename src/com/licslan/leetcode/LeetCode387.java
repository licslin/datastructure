package com.licslan.leetcode;
/**
 * 背后隐藏了哈希表的数据结构
 * int[26] freq 就是一个哈希表
 * 每一个字符都和一个索引相对应
 * a-0;
 * b-1
 * c-2
 * ....
 * z-25
 *
 * index = ch-'a'
 * 修改查找 O(1)
 * 将键转换为索引方式    设计一个合理的哈希函数  在哈希表上操作
 *
 * 哈希冲突：2个不同的键 通过哈希函数转换后产生一样的索引 这个就是哈希冲突  如何解决哈希冲突呢？ plz look at HashMap
 * 哈希表充分体现了算法领域的经典思想  --- 空间换时间   很多时候我们多存储一些东西 或者多预处理或者缓存一些东西  在执行
 * 我们的算法任务时候  得到结果的效率就会快很多  哈希表是空间和时间之间的平衡
 * "键"通过哈希函数后得到的"索引"越均匀也好  哈希冲突就越少
 *
 * 什么是哈希表这种数据结构呢？
 * 其实就是把我们关心的键通过哈希函数转换成一个索引  然后把我们的内容存在一个数组中   index --> array value
 * 哈希函数设计  ？  有专门的论文会探讨  这里主要讲解一些一般的哈希函数设计原则
 *
 * 大整数设计哈希函数
 * 一个简单的解决办法  取模一个素数会更好  取模一个合数不是更好的办法  背后的数学理论超出课程范畴  和数论有关
 * 那么这个素数如何选择也是和你这个大整数有关的 减少hash冲突 请参考 http://planetmath.org/goodhashtableprimes
 * 10 % 4 -->2   10 % 7 -->3
 * 20 % 4 -->0   20 % 7 -->6
 * 30 % 4 -->2   30 % 7 -->2
 * 40 % 4 -->0   40 % 7 -->4
 * 50 % 4 -->2   50 % 7 -->1
 *
 * 浮点型设计哈希函数  在计算机中都是32位或者64位的二进制位表示 只不过计算机解析成了浮点数
 * sign  exponent(8-bit)                fraction(23-bit)   ---->  32位
 * 0     0 1 1 1 1 1 1 1    0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 * 31                       23                                          0    <----index
 * sign  exponent(11-bit)                fraction(64-bit)   ---->  64位
 * 0     0 1 1 1 1 1 1 1 1 1 1     0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 * 63                        52                                                                                                          0  <----index
 * 将浮点型所占用的空间转换成整形  再转换成索引就可以了 就可以按照上面的方式计算了
 * 通过上面我们发现通过一个素数取模  得到的结构分布更加均匀
 *
 * 字符串设计哈希函数
 * 字符串也转换成整型处理
 * 166 = 1*10^2 + 6*10^1 + 6*10^0      <---10进制
 * code  = c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0   <---26进制
 * code  = c * X^3 + o * X^2 + d * X^1 + e * X^0   <---X进制
 * hash(code) = (c * X^3 + o * X^2 + d * X^1 + e * X^0) % M
 * hash(code) = ((((c * X)+ o) * X + d) * X + e) % M
 * hash(code) = ((((c%M) * X+ o)%M  * X + d)%M * X + e) % M
 *
 *
 * 转成整形并不是唯一的方法
 * 原则：
 * 1.一致性  若 a==b hash(a)==hash(b)
 * 2.高效性 计算高效简便
 * 3.均匀性 哈希值均匀分布
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * 哈希冲突如何解决？
 *
 *
 *
 * */
public class LeetCode387 {

    public int firstUniqChar(String s){
        int[] freq = new int[26];
        for(int i=0;i<s.length();i++)
            freq[s.charAt(i)-'a'] ++;

        for(int i=0;i<s.length();i++)
            if(freq[s.charAt(i)-'a']==1)
                return i;
            return -1;
    }
}
